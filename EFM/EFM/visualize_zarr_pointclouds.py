#!/usr/bin/env python3
"""
Visualize Point Clouds from Zarr Dataset

This script reads zarr files generated by create_zarr_real_robot.py
and visualizes specific frames/demonstrations to verify the point cloud quality.
"""

import zarr
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import argparse
from typing import List, Tuple, Optional


def enable_zoom_on_3d_axes(fig, axes_list):
    """
    Enable scroll wheel zoom on 3D matplotlib axes.
    
    Args:
        fig: matplotlib figure
        axes_list: list of 3D axes to enable zoom on
    """
    def on_scroll(event):
        if event.inaxes is None:
            return
        
        # Find which axis was scrolled on
        ax = event.inaxes
        if ax not in axes_list:
            return
        
        # Zoom factor
        zoom_factor = 1.1 if event.button == 'down' else 0.9
        
        # Get current limits
        xlim = ax.get_xlim3d()
        ylim = ax.get_ylim3d()
        zlim = ax.get_zlim3d()
        
        # Calculate centers
        x_center = (xlim[0] + xlim[1]) / 2
        y_center = (ylim[0] + ylim[1]) / 2
        z_center = (zlim[0] + zlim[1]) / 2
        
        # Calculate new ranges
        x_range = (xlim[1] - xlim[0]) * zoom_factor / 2
        y_range = (ylim[1] - ylim[0]) * zoom_factor / 2
        z_range = (zlim[1] - zlim[0]) * zoom_factor / 2
        
        # Set new limits
        ax.set_xlim3d([x_center - x_range, x_center + x_range])
        ax.set_ylim3d([y_center - y_range, y_center + y_range])
        ax.set_zlim3d([z_center - z_range, z_center + z_range])
        
        fig.canvas.draw_idle()
    
    fig.canvas.mpl_connect('scroll_event', on_scroll)
    print("üñ±Ô∏è  Scroll wheel zoom enabled (scroll up = zoom in, scroll down = zoom out)")


class ZarrPointCloudVisualizer:
    def __init__(self, zarr_path: str):
        """
        Initialize the visualizer.
        
        Args:
            zarr_path: Path to the zarr file to visualize
        """
        self.zarr_path = zarr_path
        self.zarr_root = zarr.open(zarr_path, mode='r')
        
        # Load data
        self.agentview_pcs = self.zarr_root['data/agentview_point_cloud']
        self.eye_in_hand_pcs = self.zarr_root['data/eye_in_hand_point_cloud']
        self.states = self.zarr_root['data/state']
        self.actions = self.zarr_root['data/action']
        
        # Load metadata
        self.episode_ends = np.array(self.zarr_root['meta/episode_ends'])
        self.num_episodes = len(self.episode_ends)
        self.total_timesteps = len(self.agentview_pcs)
        
        print(f"üìÇ Loaded zarr file: {zarr_path}")
        print(f"   Total episodes: {self.num_episodes}")
        print(f"   Total timesteps: {self.total_timesteps:,}")
        print(f"   Point cloud shape: {self.agentview_pcs.shape}")
        
    def get_episode_indices(self, episode_idx: int) -> Tuple[int, int]:
        """
        Get start and end indices for a specific episode.
        
        Args:
            episode_idx: Episode index (0-based)
            
        Returns:
            Tuple of (start_idx, end_idx)
        """
        if episode_idx < 0 or episode_idx >= self.num_episodes:
            raise ValueError(f"Episode index {episode_idx} out of range [0, {self.num_episodes-1}]")
        
        start_idx = 0 if episode_idx == 0 else self.episode_ends[episode_idx - 1]
        end_idx = self.episode_ends[episode_idx]
        
        return start_idx, end_idx
    
    def get_valid_points(self, pointcloud: np.ndarray) -> np.ndarray:
        """
        Extract valid (non-zero) points from a point cloud.
        
        Args:
            pointcloud: Array of shape (N, 6) with [x, y, z, r, g, b]
            
        Returns:
            Valid points array
        """
        # Check if any of x, y, z is non-zero
        valid_mask = np.any(pointcloud[:, :3] != 0, axis=1)
        return pointcloud[valid_mask]
    
    def plot_pointcloud(self, ax: plt.Axes, pointcloud: np.ndarray, title: str, 
                       point_size: int = 1, max_points_display: int = None):
        """
        Plot a single point cloud in 3D.
        
        Args:
            ax: Matplotlib 3D axis
            pointcloud: Array of shape (N, 6) with [x, y, z, r, g, b]
            title: Plot title
            point_size: Size of points in the plot
            max_points_display: Maximum number of points to display (for performance)
        """
        # Get valid points
        valid_points = self.get_valid_points(pointcloud)
        
        if len(valid_points) == 0:
            ax.text(0.5, 0.5, 0.5, 'No valid points', ha='center', va='center')
            ax.set_title(f"{title}\n(0 points)")
            return
        
        # Downsample for display if needed
        if max_points_display and len(valid_points) > max_points_display:
            indices = np.random.choice(len(valid_points), max_points_display, replace=False)
            valid_points = valid_points[indices]
        
        # Extract XYZ and RGB
        xyz = valid_points[:, :3]
        rgb = valid_points[:, 3:6] / 255.0  # Normalize to [0, 1]
        
        # Plot
        ax.scatter(xyz[:, 0], xyz[:, 1], xyz[:, 2], 
                  c=rgb, s=point_size, alpha=0.8)
        
        # Set labels and title
        ax.set_xlabel('X (m)')
        ax.set_ylabel('Y (m)')
        ax.set_zlabel('Z (m)')
        ax.set_title(f"{title}\n({len(valid_points):,} points)")
        
        # Set equal aspect ratio
        max_range = np.array([xyz[:, 0].max() - xyz[:, 0].min(),
                             xyz[:, 1].max() - xyz[:, 1].min(),
                             xyz[:, 2].max() - xyz[:, 2].min()]).max() / 2.0
        
        mid_x = (xyz[:, 0].max() + xyz[:, 0].min()) * 0.5
        mid_y = (xyz[:, 1].max() + xyz[:, 1].min()) * 0.5
        mid_z = (xyz[:, 2].max() + xyz[:, 2].min()) * 0.5
        
        ax.set_xlim(mid_x - max_range, mid_x + max_range)
        ax.set_ylim(mid_y - max_range, mid_y + max_range)
        ax.set_zlim(mid_z - max_range, mid_z + max_range)
    
    def visualize_frame(self, frame_idx: int, point_size: int = 1, 
                       max_points_display: int = 4096, save_path: Optional[str] = None):
        """
        Visualize both point clouds for a specific frame.
        
        Args:
            frame_idx: Global frame index to visualize
            point_size: Size of points in the plot
            max_points_display: Maximum number of points to display per cloud
            save_path: Optional path to save the figure
        """
        if frame_idx < 0 or frame_idx >= self.total_timesteps:
            raise ValueError(f"Frame index {frame_idx} out of range [0, {self.total_timesteps-1}]")
        
        # Find which episode this frame belongs to
        episode_idx = np.searchsorted(self.episode_ends, frame_idx + 1)
        start_idx, end_idx = self.get_episode_indices(episode_idx)
        local_frame_idx = frame_idx - start_idx
        
        # Get point clouds
        agentview_pc = self.agentview_pcs[frame_idx]
        eye_in_hand_pc = self.eye_in_hand_pcs[frame_idx]
        
        # Get state and action
        state = self.states[frame_idx]
        action = self.actions[frame_idx]
        
        # Create figure with two subplots
        fig = plt.figure(figsize=(16, 7))
        
        # Plot agentview point cloud
        ax1 = fig.add_subplot(121, projection='3d')
        self.plot_pointcloud(ax1, agentview_pc, 'AgentView Point Cloud', 
                           point_size, max_points_display)
        
        # Plot eye-in-hand point cloud
        ax2 = fig.add_subplot(122, projection='3d')
        self.plot_pointcloud(ax2, eye_in_hand_pc, 'Eye-in-Hand Point Cloud', 
                           point_size, max_points_display)
        
        # Add overall title with frame info
        fig.suptitle(f'Frame {frame_idx} (Episode {episode_idx}, Local Frame {local_frame_idx}/{end_idx-start_idx-1})\n' +
                    f'State: [{state[0]:.3f}, {state[1]:.3f}, ...] (21D)  |  ' +
                    f'Action: {action}',
                    fontsize=12, y=0.98)
        
        plt.tight_layout()
        
        # Enable scroll wheel zoom on both 3D axes
        enable_zoom_on_3d_axes(fig, [ax1, ax2])
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"üíæ Saved visualization to {save_path}")
        
        plt.show()
    
    def visualize_episode_frames(self, episode_idx: int, frame_indices: List[int] = None,
                                num_frames: int = 5, point_size: int = 1, 
                                max_points_display: int = 4096, save_dir: Optional[str] = None):
        """
        Visualize multiple frames from a specific episode.
        
        Args:
            episode_idx: Episode index to visualize
            frame_indices: List of local frame indices within the episode (if None, evenly spaced)
            num_frames: Number of frames to show if frame_indices not provided
            point_size: Size of points in the plot
            max_points_display: Maximum number of points to display per cloud
            save_dir: Optional directory to save figures
        """
        start_idx, end_idx = self.get_episode_indices(episode_idx)
        episode_length = end_idx - start_idx
        
        print(f"\nüì∫ Visualizing Episode {episode_idx}")
        print(f"   Episode length: {episode_length} frames")
        print(f"   Global indices: [{start_idx}, {end_idx})")
        
        # Determine which frames to visualize
        if frame_indices is None:
            # Evenly spaced frames
            if num_frames >= episode_length:
                local_indices = list(range(episode_length))
            else:
                local_indices = [int(i * episode_length / num_frames) 
                               for i in range(num_frames)]
        else:
            local_indices = frame_indices
        
        # Visualize each frame
        for local_idx in local_indices:
            if local_idx >= episode_length:
                print(f"‚ö†Ô∏è  Skipping local frame {local_idx} (out of range)")
                continue
            
            global_idx = start_idx + local_idx
            
            save_path = None
            if save_dir:
                import os
                os.makedirs(save_dir, exist_ok=True)
                save_path = os.path.join(save_dir, 
                                        f"episode_{episode_idx}_frame_{local_idx}.png")
            
            print(f"\nüé® Visualizing frame {local_idx}/{episode_length-1} (global index {global_idx})")
            self.visualize_frame(global_idx, point_size, max_points_display, save_path)
    
    def print_dataset_info(self):
        """Print detailed information about the dataset."""
        print("\n" + "=" * 80)
        print("üìä ZARR DATASET INFORMATION")
        print("=" * 80)
        
        print(f"\nüìÇ File: {self.zarr_path}")
        print(f"\nüìê Data Shapes:")
        print(f"   AgentView Point Clouds: {self.agentview_pcs.shape}")
        print(f"   Eye-in-Hand Point Clouds: {self.eye_in_hand_pcs.shape}")
        print(f"   States: {self.states.shape}")
        print(f"   Actions: {self.actions.shape}")
        
        print(f"\nüé¨ Episodes:")
        print(f"   Total episodes: {self.num_episodes}")
        print(f"   Total timesteps: {self.total_timesteps:,}")
        
        # Print episode lengths
        episode_lengths = []
        for i in range(self.num_episodes):
            start_idx, end_idx = self.get_episode_indices(i)
            length = end_idx - start_idx
            episode_lengths.append(length)
            print(f"   Episode {i}: {length} frames (indices {start_idx}-{end_idx-1})")
        
        print(f"\nüìà Episode Statistics:")
        print(f"   Min length: {min(episode_lengths)} frames")
        print(f"   Max length: {max(episode_lengths)} frames")
        print(f"   Mean length: {np.mean(episode_lengths):.1f} frames")
        
        # Sample point cloud statistics
        print(f"\nüîç Sample Point Cloud Statistics (first frame):")
        sample_agentview = self.agentview_pcs[0]
        sample_eye_in_hand = self.eye_in_hand_pcs[0]
        
        agentview_valid = self.get_valid_points(sample_agentview)
        eye_in_hand_valid = self.get_valid_points(sample_eye_in_hand)
        
        print(f"   AgentView valid points: {len(agentview_valid):,} / {len(sample_agentview):,}")
        print(f"   Eye-in-Hand valid points: {len(eye_in_hand_valid):,} / {len(sample_eye_in_hand):,}")
        
        if len(agentview_valid) > 0:
            xyz = agentview_valid[:, :3]
            print(f"   AgentView XYZ range:")
            print(f"     X: [{xyz[:, 0].min():.3f}, {xyz[:, 0].max():.3f}]")
            print(f"     Y: [{xyz[:, 1].min():.3f}, {xyz[:, 1].max():.3f}]")
            print(f"     Z: [{xyz[:, 2].min():.3f}, {xyz[:, 2].max():.3f}]")
        
        # Check metadata
        if 'meta' in self.zarr_root:
            meta = self.zarr_root['meta']
            if hasattr(meta, 'attrs'):
                print(f"\nüìù Metadata:")
                for key, value in meta.attrs.items():
                    if key != 'config':  # Skip verbose config
                        print(f"   {key}: {value}")
        
        print("=" * 80)


def main():
    """Main function with command-line interface."""
    parser = argparse.ArgumentParser(
        description='Visualize point clouds from zarr dataset')
    
    parser.add_argument('--zarr_path', type=str, 
                       default='/media/carl_ma/MyPassport/stacking_cups/stacking_cups_dual_view.zarr',
                       help='Path to the zarr file')
    
    parser.add_argument('--episode', type=int, default=0,
                       help='Episode index to visualize')
    
    parser.add_argument('--frames', type=int, nargs='+', default=None,
                       help='Specific frame indices within episode to visualize (e.g., --frames 0 10 20)')
    
    parser.add_argument('--num_frames', type=int, default=5,
                       help='Number of evenly spaced frames to show if --frames not specified')
    
    parser.add_argument('--global_frame', type=int, default=None,
                       help='Visualize a specific global frame index (overrides episode/frames)')
    
    parser.add_argument('--point_size', type=int, default=1,
                       help='Size of points in visualization')
    
    parser.add_argument('--max_points', type=int, default=8192,
                       help='Maximum points to display per cloud (for performance)')
    
    parser.add_argument('--save_dir', type=str, default=None,
                       help='Directory to save visualizations')
    
    parser.add_argument('--info', action='store_true',
                       help='Print dataset information and exit')
    
    args = parser.parse_args()
    
    # Initialize visualizer
    try:
        visualizer = ZarrPointCloudVisualizer(args.zarr_path)
    except Exception as e:
        print(f"‚ùå Error loading zarr file: {e}")
        return
    
    # Print info if requested
    if args.info:
        visualizer.print_dataset_info()
        return
    
    # Visualize
    try:
        if args.global_frame is not None:
            # Visualize specific global frame
            visualizer.visualize_frame(
                args.global_frame, 
                point_size=args.point_size,
                max_points_display=args.max_points,
                save_path=f"{args.save_dir}/frame_{args.global_frame}.png" if args.save_dir else None
            )
        else:
            # Visualize episode frames
            visualizer.visualize_episode_frames(
                args.episode,
                frame_indices=args.frames,
                num_frames=args.num_frames,
                point_size=args.point_size,
                max_points_display=args.max_points,
                save_dir=args.save_dir
            )
    except Exception as e:
        print(f"‚ùå Error during visualization: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
